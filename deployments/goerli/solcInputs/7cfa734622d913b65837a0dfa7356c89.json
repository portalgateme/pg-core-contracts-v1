{
  "language": "Solidity",
  "sources": {
    "@openzeppelin/contracts/access/Ownable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.9.0) (access/Ownable.sol)\n\npragma solidity ^0.8.0;\n\nimport \"../utils/Context.sol\";\n\n/**\n * @dev Contract module which provides a basic access control mechanism, where\n * there is an account (an owner) that can be granted exclusive access to\n * specific functions.\n *\n * By default, the owner account will be the one that deploys the contract. This\n * can later be changed with {transferOwnership}.\n *\n * This module is used through inheritance. It will make available the modifier\n * `onlyOwner`, which can be applied to your functions to restrict their use to\n * the owner.\n */\nabstract contract Ownable is Context {\n    address private _owner;\n\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\n\n    /**\n     * @dev Initializes the contract setting the deployer as the initial owner.\n     */\n    constructor() {\n        _transferOwnership(_msgSender());\n    }\n\n    /**\n     * @dev Throws if called by any account other than the owner.\n     */\n    modifier onlyOwner() {\n        _checkOwner();\n        _;\n    }\n\n    /**\n     * @dev Returns the address of the current owner.\n     */\n    function owner() public view virtual returns (address) {\n        return _owner;\n    }\n\n    /**\n     * @dev Throws if the sender is not the owner.\n     */\n    function _checkOwner() internal view virtual {\n        require(owner() == _msgSender(), \"Ownable: caller is not the owner\");\n    }\n\n    /**\n     * @dev Leaves the contract without owner. It will not be possible to call\n     * `onlyOwner` functions. Can only be called by the current owner.\n     *\n     * NOTE: Renouncing ownership will leave the contract without an owner,\n     * thereby disabling any functionality that is only available to the owner.\n     */\n    function renounceOwnership() public virtual onlyOwner {\n        _transferOwnership(address(0));\n    }\n\n    /**\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\n     * Can only be called by the current owner.\n     */\n    function transferOwnership(address newOwner) public virtual onlyOwner {\n        require(newOwner != address(0), \"Ownable: new owner is the zero address\");\n        _transferOwnership(newOwner);\n    }\n\n    /**\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\n     * Internal function without access restriction.\n     */\n    function _transferOwnership(address newOwner) internal virtual {\n        address oldOwner = _owner;\n        _owner = newOwner;\n        emit OwnershipTransferred(oldOwner, newOwner);\n    }\n}\n"
    },
    "@openzeppelin/contracts/token/ERC20/IERC20.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.9.0) (token/ERC20/IERC20.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Interface of the ERC20 standard as defined in the EIP.\n */\ninterface IERC20 {\n    /**\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\n     * another (`to`).\n     *\n     * Note that `value` may be zero.\n     */\n    event Transfer(address indexed from, address indexed to, uint256 value);\n\n    /**\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\n     * a call to {approve}. `value` is the new allowance.\n     */\n    event Approval(address indexed owner, address indexed spender, uint256 value);\n\n    /**\n     * @dev Returns the amount of tokens in existence.\n     */\n    function totalSupply() external view returns (uint256);\n\n    /**\n     * @dev Returns the amount of tokens owned by `account`.\n     */\n    function balanceOf(address account) external view returns (uint256);\n\n    /**\n     * @dev Moves `amount` tokens from the caller's account to `to`.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transfer(address to, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Returns the remaining number of tokens that `spender` will be\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\n     * zero by default.\n     *\n     * This value changes when {approve} or {transferFrom} are called.\n     */\n    function allowance(address owner, address spender) external view returns (uint256);\n\n    /**\n     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\n     * that someone may use both the old and the new allowance by unfortunate\n     * transaction ordering. One possible solution to mitigate this race\n     * condition is to first reduce the spender's allowance to 0 and set the\n     * desired value afterwards:\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\n     *\n     * Emits an {Approval} event.\n     */\n    function approve(address spender, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Moves `amount` tokens from `from` to `to` using the\n     * allowance mechanism. `amount` is then deducted from the caller's\n     * allowance.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transferFrom(address from, address to, uint256 amount) external returns (bool);\n}\n"
    },
    "@openzeppelin/contracts/utils/Context.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (utils/Context.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Provides information about the current execution context, including the\n * sender of the transaction and its data. While these are generally available\n * via msg.sender and msg.data, they should not be accessed in such a direct\n * manner, since when dealing with meta-transactions the account sending and\n * paying for execution may not be the actual sender (as far as an application\n * is concerned).\n *\n * This contract is only required for intermediate, library-like contracts.\n */\nabstract contract Context {\n    function _msgSender() internal view virtual returns (address) {\n        return msg.sender;\n    }\n\n    function _msgData() internal view virtual returns (bytes calldata) {\n        return msg.data;\n    }\n}\n"
    },
    "@openzeppelin/contracts/utils/math/SafeMath.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.9.0) (utils/math/SafeMath.sol)\n\npragma solidity ^0.8.0;\n\n// CAUTION\n// This version of SafeMath should only be used with Solidity 0.8 or later,\n// because it relies on the compiler's built in overflow checks.\n\n/**\n * @dev Wrappers over Solidity's arithmetic operations.\n *\n * NOTE: `SafeMath` is generally not needed starting with Solidity 0.8, since the compiler\n * now has built in overflow checking.\n */\nlibrary SafeMath {\n    /**\n     * @dev Returns the addition of two unsigned integers, with an overflow flag.\n     *\n     * _Available since v3.4._\n     */\n    function tryAdd(uint256 a, uint256 b) internal pure returns (bool, uint256) {\n        unchecked {\n            uint256 c = a + b;\n            if (c < a) return (false, 0);\n            return (true, c);\n        }\n    }\n\n    /**\n     * @dev Returns the subtraction of two unsigned integers, with an overflow flag.\n     *\n     * _Available since v3.4._\n     */\n    function trySub(uint256 a, uint256 b) internal pure returns (bool, uint256) {\n        unchecked {\n            if (b > a) return (false, 0);\n            return (true, a - b);\n        }\n    }\n\n    /**\n     * @dev Returns the multiplication of two unsigned integers, with an overflow flag.\n     *\n     * _Available since v3.4._\n     */\n    function tryMul(uint256 a, uint256 b) internal pure returns (bool, uint256) {\n        unchecked {\n            // Gas optimization: this is cheaper than requiring 'a' not being zero, but the\n            // benefit is lost if 'b' is also tested.\n            // See: https://github.com/OpenZeppelin/openzeppelin-contracts/pull/522\n            if (a == 0) return (true, 0);\n            uint256 c = a * b;\n            if (c / a != b) return (false, 0);\n            return (true, c);\n        }\n    }\n\n    /**\n     * @dev Returns the division of two unsigned integers, with a division by zero flag.\n     *\n     * _Available since v3.4._\n     */\n    function tryDiv(uint256 a, uint256 b) internal pure returns (bool, uint256) {\n        unchecked {\n            if (b == 0) return (false, 0);\n            return (true, a / b);\n        }\n    }\n\n    /**\n     * @dev Returns the remainder of dividing two unsigned integers, with a division by zero flag.\n     *\n     * _Available since v3.4._\n     */\n    function tryMod(uint256 a, uint256 b) internal pure returns (bool, uint256) {\n        unchecked {\n            if (b == 0) return (false, 0);\n            return (true, a % b);\n        }\n    }\n\n    /**\n     * @dev Returns the addition of two unsigned integers, reverting on\n     * overflow.\n     *\n     * Counterpart to Solidity's `+` operator.\n     *\n     * Requirements:\n     *\n     * - Addition cannot overflow.\n     */\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\n        return a + b;\n    }\n\n    /**\n     * @dev Returns the subtraction of two unsigned integers, reverting on\n     * overflow (when the result is negative).\n     *\n     * Counterpart to Solidity's `-` operator.\n     *\n     * Requirements:\n     *\n     * - Subtraction cannot overflow.\n     */\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\n        return a - b;\n    }\n\n    /**\n     * @dev Returns the multiplication of two unsigned integers, reverting on\n     * overflow.\n     *\n     * Counterpart to Solidity's `*` operator.\n     *\n     * Requirements:\n     *\n     * - Multiplication cannot overflow.\n     */\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\n        return a * b;\n    }\n\n    /**\n     * @dev Returns the integer division of two unsigned integers, reverting on\n     * division by zero. The result is rounded towards zero.\n     *\n     * Counterpart to Solidity's `/` operator.\n     *\n     * Requirements:\n     *\n     * - The divisor cannot be zero.\n     */\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\n        return a / b;\n    }\n\n    /**\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\n     * reverting when dividing by zero.\n     *\n     * Counterpart to Solidity's `%` operator. This function uses a `revert`\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\n     * invalid opcode to revert (consuming all remaining gas).\n     *\n     * Requirements:\n     *\n     * - The divisor cannot be zero.\n     */\n    function mod(uint256 a, uint256 b) internal pure returns (uint256) {\n        return a % b;\n    }\n\n    /**\n     * @dev Returns the subtraction of two unsigned integers, reverting with custom message on\n     * overflow (when the result is negative).\n     *\n     * CAUTION: This function is deprecated because it requires allocating memory for the error\n     * message unnecessarily. For custom revert reasons use {trySub}.\n     *\n     * Counterpart to Solidity's `-` operator.\n     *\n     * Requirements:\n     *\n     * - Subtraction cannot overflow.\n     */\n    function sub(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\n        unchecked {\n            require(b <= a, errorMessage);\n            return a - b;\n        }\n    }\n\n    /**\n     * @dev Returns the integer division of two unsigned integers, reverting with custom message on\n     * division by zero. The result is rounded towards zero.\n     *\n     * Counterpart to Solidity's `/` operator. Note: this function uses a\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\n     * uses an invalid opcode to revert (consuming all remaining gas).\n     *\n     * Requirements:\n     *\n     * - The divisor cannot be zero.\n     */\n    function div(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\n        unchecked {\n            require(b > 0, errorMessage);\n            return a / b;\n        }\n    }\n\n    /**\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\n     * reverting with custom message when dividing by zero.\n     *\n     * CAUTION: This function is deprecated because it requires allocating memory for the error\n     * message unnecessarily. For custom revert reasons use {tryMod}.\n     *\n     * Counterpart to Solidity's `%` operator. This function uses a `revert`\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\n     * invalid opcode to revert (consuming all remaining gas).\n     *\n     * Requirements:\n     *\n     * - The divisor cannot be zero.\n     */\n    function mod(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\n        unchecked {\n            require(b > 0, errorMessage);\n            return a % b;\n        }\n    }\n}\n"
    },
    "contracts/interfaces/IHasher.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\n\ninterface IHasher {\n  function poseidon(bytes32[2] calldata inputs) external pure returns (bytes32);\n\n  function poseidon(bytes32[3] calldata inputs) external pure returns (bytes32);\n}\n"
    },
    "contracts/interfaces/IRewardSwap.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\n\ninterface IRewardSwap {\n  function swap(address recipient, uint256 amount) external returns (uint256);\n\n  function setPoolWeight(uint256 newWeight) external;\n}\n"
    },
    "contracts/interfaces/ITornadoTrees.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\n\ninterface ITornadoTrees {\n  function registerDeposit(address instance, bytes32 commitment) external;\n\n  function registerWithdrawal(address instance, bytes32 nullifier) external;\n}\n"
    },
    "contracts/interfaces/IVerifier.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\n\ninterface IVerifier {\n  function verifyProof(bytes calldata proof, uint256[4] calldata input) external view returns (bool);\n\n  function verifyProof(bytes calldata proof, uint256[7] calldata input) external view returns (bool);\n\n  function verifyProof(bytes calldata proof, uint256[12] calldata input) external view returns (bool);\n}\n"
    },
    "contracts/libs/OwnableMerkleTree.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\nimport \"@openzeppelin/contracts/access/Ownable.sol\";\nimport \"../tornado-core/MerkleTreeWithHistory.sol\";\n\ncontract OwnableMerkleTree is Ownable, MerkleTreeWithHistory {\n  constructor(uint32 _treeLevels, IHasher _hasher) MerkleTreeWithHistory(_treeLevels, _hasher) {}\n\n  function insert(bytes32 _leaf) external onlyOwner returns (uint32 index) {\n    return _insert(_leaf);\n  }\n\n  function bulkInsert(bytes32[] calldata _leaves) external onlyOwner {\n    _bulkInsert(_leaves);\n  }\n}\n"
    },
    "contracts/mocks/MockTornadoTree.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\n\nimport \"../tornado-core/TornadoTrees.sol\";\n\ncontract MockTornadoTrees is TornadoTrees {\n  uint256 public timestamp;\n  uint256 public currentBlock;\n\n  constructor(\n    address _pgRouter,\n    address _hasher2,\n    address _hasher3,\n    uint32 _levels\n  ) TornadoTrees(_pgRouter, _hasher2, _hasher3, _levels) {}\n\n  function setBlockNumber(uint256 _blockNumber) public {\n    currentBlock = _blockNumber;\n  }\n\n  function blockNumber() public view override returns (uint256) {\n    return currentBlock == 0 ? block.number : currentBlock;\n  }\n}\n"
    },
    "contracts/tornado-core/MerkleTreeWithHistory.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\nimport \"../interfaces/IHasher.sol\";\n\ncontract MerkleTreeWithHistory {\n  uint256 public constant FIELD_SIZE = 21888242871839275222246405745257275088548364400416034343698204186575808495617;\n  uint256 public constant ZERO_VALUE = 21663839004416932945382355908790599225266501822907911457504978515578255421292; // = keccak256(\"tornado\") % FIELD_SIZE\n\n  uint32 public immutable levels;\n  IHasher public hasher;\n\n  bytes32[] public filledSubtrees;\n  bytes32[] public zeros;\n  uint32 public currentRootIndex = 0;\n  uint32 public nextIndex = 0;\n  uint32 public constant ROOT_HISTORY_SIZE = 10;\n  bytes32[ROOT_HISTORY_SIZE] public roots;\n\n  constructor(uint32 _treeLevels, IHasher _hasher) {\n    require(_treeLevels > 0, \"_treeLevels should be greater than zero\");\n    require(_treeLevels < 32, \"_treeLevels should be less than 32\");\n    levels = _treeLevels;\n    hasher = _hasher;\n\n    bytes32 currentZero = bytes32(ZERO_VALUE);\n    zeros.push(currentZero);\n    filledSubtrees.push(currentZero);\n\n    for (uint32 i = 1; i < _treeLevels; i++) {\n      currentZero = hashLeftRight(currentZero, currentZero);\n      zeros.push(currentZero);\n      filledSubtrees.push(currentZero);\n    }\n\n    filledSubtrees.push(hashLeftRight(currentZero, currentZero));\n    roots[0] = filledSubtrees[_treeLevels];\n  }\n\n  /**\n    @dev Hash 2 tree leaves, returns poseidon(_left, _right)\n  */\n  function hashLeftRight(bytes32 _left, bytes32 _right) public view returns (bytes32) {\n    return hasher.poseidon([_left, _right]);\n  }\n\n  function _insert(bytes32 _leaf) internal returns (uint32 index) {\n    uint32 currentIndex = nextIndex;\n    require(currentIndex != uint32(2)**levels, \"Merkle tree is full. No more leaves can be added\");\n    nextIndex = currentIndex + 1;\n    bytes32 currentLevelHash = _leaf;\n    bytes32 left;\n    bytes32 right;\n\n    for (uint32 i = 0; i < levels; i++) {\n      if (currentIndex % 2 == 0) {\n        left = currentLevelHash;\n        right = zeros[i];\n        filledSubtrees[i] = currentLevelHash;\n      } else {\n        left = filledSubtrees[i];\n        right = currentLevelHash;\n      }\n\n      currentLevelHash = hashLeftRight(left, right);\n      currentIndex /= 2;\n    }\n\n    currentRootIndex = (currentRootIndex + 1) % ROOT_HISTORY_SIZE;\n    roots[currentRootIndex] = currentLevelHash;\n    return nextIndex - 1;\n  }\n\n  function _bulkInsert(bytes32[] memory _leaves) internal {\n    uint32 insertIndex = nextIndex;\n    require(insertIndex + _leaves.length <= uint32(2)**levels, \"Merkle doesn't have enough capacity to add specified leaves\");\n\n    bytes32[] memory subtrees = new bytes32[](levels);\n    bool[] memory modifiedSubtrees = new bool[](levels);\n    for (uint32 j = 0; j < _leaves.length - 1; j++) {\n      uint256 index = insertIndex + j;\n      bytes32 currentLevelHash = _leaves[j];\n\n      for (uint32 i = 0; ; i++) {\n        if (index % 2 == 0) {\n          modifiedSubtrees[i] = true;\n          subtrees[i] = currentLevelHash;\n          break;\n        }\n\n        if (subtrees[i] == bytes32(0)) {\n          subtrees[i] = filledSubtrees[i];\n        }\n        currentLevelHash = hashLeftRight(subtrees[i], currentLevelHash);\n        index /= 2;\n      }\n    }\n\n    for (uint32 i = 0; i < levels; i++) {\n      // using local map to save on gas on writes if elements were not modified\n      if (modifiedSubtrees[i]) {\n        filledSubtrees[i] = subtrees[i];\n      }\n    }\n\n    nextIndex = uint32(insertIndex + _leaves.length - 1);\n    _insert(_leaves[_leaves.length - 1]);\n  }\n\n  /**\n    @dev Whether the root is present in the root history\n  */\n  function isKnownRoot(bytes32 _root) public view returns (bool) {\n    if (_root == 0) {\n      return false;\n    }\n    uint32 i = currentRootIndex;\n    do {\n      if (_root == roots[i]) {\n        return true;\n      }\n      if (i == 0) {\n        i = ROOT_HISTORY_SIZE;\n      }\n      i--;\n    } while (i != currentRootIndex);\n    return false;\n  }\n\n  /**\n    @dev Returns the last root\n  */\n  function getLastRoot() public view returns (bytes32) {\n    return roots[currentRootIndex];\n  }\n}\n"
    },
    "contracts/tornado-core/Miner.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\n\nimport \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport \"@openzeppelin/contracts/utils/math/SafeMath.sol\";\nimport \"../interfaces/IVerifier.sol\";\nimport \"../interfaces/IRewardSwap.sol\";\nimport \"./TornadoTrees.sol\";\n\ncontract Miner {\n  using SafeMath for uint256;\n\n  IVerifier public rewardVerifier;\n  IVerifier public withdrawVerifier;\n  IVerifier public treeUpdateVerifier;\n//  IRewardSwap public rewardSwap;\n  address public immutable governance;\n  TornadoTrees public tornadoTrees;\n\n  mapping(bytes32 => bool) public accountNullifiers;\n  mapping(bytes32 => bool) public rewardNullifiers;\n  mapping(address => uint256) public rates;\n\n  uint256 public accountCount;\n  uint256 public constant ACCOUNT_ROOT_HISTORY_SIZE = 100;\n  bytes32[ACCOUNT_ROOT_HISTORY_SIZE] public accountRoots;\n\n  event NewAccount(bytes32 commitment, bytes32 nullifier, bytes encryptedAccount, uint256 index);\n  event RateChanged(address instance, uint256 value);\n  event VerifiersUpdated(address reward, address withdraw, address treeUpdate);\n\n  struct TreeUpdateArgs {\n    bytes32 oldRoot;\n    bytes32 newRoot;\n    bytes32 leaf;\n    uint256 pathIndices;\n  }\n\n  struct AccountUpdate {\n    bytes32 inputRoot;\n    bytes32 inputNullifierHash;\n    bytes32 outputRoot;\n    uint256 outputPathIndices;\n    bytes32 outputCommitment;\n  }\n\n  struct RewardExtData {\n    address relayer;\n    bytes encryptedAccount;\n  }\n\n  struct RewardArgs {\n    uint256 rate;\n    uint256 fee;\n    address instance;\n    bytes32 rewardNullifier;\n    bytes32 extDataHash;\n    bytes32 depositRoot;\n    bytes32 withdrawalRoot;\n    RewardExtData extData;\n    AccountUpdate account;\n  }\n\n  struct WithdrawExtData {\n    uint256 fee;\n    address recipient;\n    address relayer;\n    bytes encryptedAccount;\n  }\n\n  struct WithdrawArgs {\n    uint256 amount;\n    bytes32 extDataHash;\n    WithdrawExtData extData;\n    AccountUpdate account;\n  }\n\n  struct Rate {\n    address instance;\n    uint256 value;\n  }\n\n  modifier onlyGovernance() {\n    require(msg.sender == governance, \"Only governance can perform this action\");\n    _;\n  }\n\n  constructor(\n//    address _rewardSwap,\n    address _governance, // operator\n    address _tornadoTrees,\n    address[3] memory _verifiers,\n    bytes32 _accountRoot,\n    Rate[] memory _rates\n  ) {\n//    rewardSwap = IRewardSwap(_rewardSwap);\n    governance = _governance;\n    tornadoTrees = TornadoTrees(_tornadoTrees);\n\n    // insert empty tree root without incrementing accountCount counter\n    accountRoots[0] = _accountRoot;\n\n    _setRates(_rates);\n    // prettier-ignore\n    _setVerifiers([\n    IVerifier(_verifiers[0]),\n    IVerifier(_verifiers[1]),\n    IVerifier(_verifiers[2])\n    ]);\n  }\n\n  function reward(bytes memory _proof, RewardArgs memory _args) public {\n    reward(_proof, _args, new bytes(0), TreeUpdateArgs(0, 0, 0, 0));\n  }\n\n  function batchReward(bytes[] calldata _rewardArgs) external {\n    for (uint256 i = 0; i < _rewardArgs.length; i++) {\n      (bytes memory proof, RewardArgs memory args) = abi.decode(_rewardArgs[i], (bytes, RewardArgs));\n      reward(proof, args);\n    }\n  }\n\n  function reward(\n    bytes memory _proof,\n    RewardArgs memory _args,\n    bytes memory _treeUpdateProof,\n    TreeUpdateArgs memory _treeUpdateArgs\n  ) public {\n    validateAccountUpdate(_args.account, _treeUpdateProof, _treeUpdateArgs);\n    tornadoTrees.validateRoots(_args.depositRoot, _args.withdrawalRoot);\n    require(_args.extDataHash == keccak248(abi.encode(_args.extData)), \"Incorrect external data hash\");\n    require(_args.fee < 2**248, \"Fee value out of range\");\n    require(_args.rate == rates[_args.instance] && _args.rate > 0, \"Invalid reward rate\");\n    require(!rewardNullifiers[_args.rewardNullifier], \"Reward has been already spent\");\n    require(\n      rewardVerifier.verifyProof(\n        _proof,\n        [\n        uint256(_args.rate),\n        uint256(_args.fee),\n        uint256(uint160(_args.instance)),\n        uint256(_args.rewardNullifier),\n        uint256(_args.extDataHash),\n        uint256(_args.account.inputRoot),\n        uint256(_args.account.inputNullifierHash),\n        uint256(_args.account.outputRoot),\n        uint256(_args.account.outputPathIndices),\n        uint256(_args.account.outputCommitment),\n        uint256(_args.depositRoot),\n        uint256(_args.withdrawalRoot)\n        ]\n      ),\n      \"Invalid reward proof\"\n    );\n\n    accountNullifiers[_args.account.inputNullifierHash] = true;\n    rewardNullifiers[_args.rewardNullifier] = true;\n    insertAccountRoot(_args.account.inputRoot == getLastAccountRoot() ? _args.account.outputRoot : _treeUpdateArgs.newRoot);\n    if (_args.fee > 0) {\n//      rewardSwap.swap(_args.extData.relayer, _args.fee);\n    }\n\n    emit NewAccount(\n      _args.account.outputCommitment,\n      _args.account.inputNullifierHash,\n      _args.extData.encryptedAccount,\n      accountCount - 1\n    );\n  }\n\n  function withdraw(bytes memory _proof, WithdrawArgs memory _args) public {\n    withdraw(_proof, _args, new bytes(0), TreeUpdateArgs(0, 0, 0, 0));\n  }\n\n  function withdraw(\n    bytes memory _proof,\n    WithdrawArgs memory _args,\n    bytes memory _treeUpdateProof,\n    TreeUpdateArgs memory _treeUpdateArgs\n  ) public {\n    validateAccountUpdate(_args.account, _treeUpdateProof, _treeUpdateArgs);\n    require(_args.extDataHash == keccak248(abi.encode(_args.extData)), \"Incorrect external data hash\");\n    require(_args.amount < 2**248, \"Amount value out of range\");\n    require(\n      withdrawVerifier.verifyProof(\n        _proof,\n        [\n        uint256(_args.amount),\n        uint256(_args.extDataHash),\n        uint256(_args.account.inputRoot),\n        uint256(_args.account.inputNullifierHash),\n        uint256(_args.account.outputRoot),\n        uint256(_args.account.outputPathIndices),\n        uint256(_args.account.outputCommitment)\n        ]\n      ),\n      \"Invalid withdrawal proof\"\n    );\n\n    insertAccountRoot(_args.account.inputRoot == getLastAccountRoot() ? _args.account.outputRoot : _treeUpdateArgs.newRoot);\n    accountNullifiers[_args.account.inputNullifierHash] = true;\n    // allow submitting noop withdrawals (amount == 0)\n    uint256 amount = _args.amount.sub(_args.extData.fee, \"Amount should be greater than fee\");\n    if (amount > 0) {\n//      rewardSwap.swap(_args.extData.recipient, amount);\n    }\n    // Note. The relayer swap rate always will be worse than estimated\n    if (_args.extData.fee > 0) {\n//      rewardSwap.swap(_args.extData.relayer, _args.extData.fee);\n    }\n\n    emit NewAccount(\n      _args.account.outputCommitment,\n      _args.account.inputNullifierHash,\n      _args.extData.encryptedAccount,\n      accountCount - 1\n    );\n  }\n\n  function setRates(Rate[] memory _rates) external onlyGovernance {\n    _setRates(_rates);\n  }\n\n  function setVerifiers(IVerifier[3] calldata _verifiers) external onlyGovernance {\n    _setVerifiers(_verifiers);\n  }\n\n  function setTornadoTreesContract(TornadoTrees _tornadoTrees) external onlyGovernance {\n    tornadoTrees = _tornadoTrees;\n  }\n\n//  function setPoolWeight(uint256 _newWeight) external onlyGovernance {\n//    rewardSwap.setPoolWeight(_newWeight);\n//  }\n\n  // ------VIEW-------\n\n  /**\n    @dev Whether the root is present in the root history\n    */\n  function isKnownAccountRoot(bytes32 _root, uint256 _index) public view returns (bool) {\n    return _root != 0 && accountRoots[_index % ACCOUNT_ROOT_HISTORY_SIZE] == _root;\n  }\n\n  /**\n    @dev Returns the last root\n    */\n  function getLastAccountRoot() public view returns (bytes32) {\n    return accountRoots[accountCount % ACCOUNT_ROOT_HISTORY_SIZE];\n  }\n\n  // -----INTERNAL-------\n\n  function keccak248(bytes memory _data) internal pure returns (bytes32) {\n    return keccak256(_data) & 0x00ffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff;\n  }\n\n  function validateTreeUpdate(\n    bytes memory _proof,\n    TreeUpdateArgs memory _args,\n    bytes32 _commitment\n  ) internal view {\n    require(_proof.length > 0, \"Outdated account merkle root\");\n    require(_args.oldRoot == getLastAccountRoot(), \"Outdated tree update merkle root\");\n    require(_args.leaf == _commitment, \"Incorrect commitment inserted\");\n    require(_args.pathIndices == accountCount, \"Incorrect account insert index\");\n    require(\n      treeUpdateVerifier.verifyProof(\n        _proof,\n        [uint256(_args.oldRoot), uint256(_args.newRoot), uint256(_args.leaf), uint256(_args.pathIndices)]\n      ),\n      \"Invalid tree update proof\"\n    );\n  }\n\n  function validateAccountUpdate(\n    AccountUpdate memory _account,\n    bytes memory _treeUpdateProof,\n    TreeUpdateArgs memory _treeUpdateArgs\n  ) internal view {\n    require(!accountNullifiers[_account.inputNullifierHash], \"Outdated account state\");\n    if (_account.inputRoot != getLastAccountRoot()) {\n      // _account.outputPathIndices (= last tree leaf index) is always equal to root index in the history mapping\n      // because we always generate a new root for each new leaf\n      require(isKnownAccountRoot(_account.inputRoot, _account.outputPathIndices), \"Invalid account root\");\n      validateTreeUpdate(_treeUpdateProof, _treeUpdateArgs, _account.outputCommitment);\n    } else {\n      require(_account.outputPathIndices == accountCount, \"Incorrect account insert index\");\n    }\n  }\n\n  function insertAccountRoot(bytes32 _root) internal {\n    accountRoots[++accountCount % ACCOUNT_ROOT_HISTORY_SIZE] = _root;\n  }\n\n  function _setRates(Rate[] memory _rates) internal {\n    for (uint256 i = 0; i < _rates.length; i++) {\n      require(_rates[i].value < 2**128, \"Incorrect rate\");\n      address instance = _rates[i].instance;\n      rates[instance] = _rates[i].value;\n      emit RateChanged(instance, _rates[i].value);\n    }\n  }\n\n  function _setVerifiers(IVerifier[3] memory _verifiers) internal {\n    rewardVerifier = _verifiers[0];\n    withdrawVerifier = _verifiers[1];\n    treeUpdateVerifier = _verifiers[2];\n    emit VerifiersUpdated(address(_verifiers[0]), address(_verifiers[1]), address(_verifiers[2]));\n  }\n}\n"
    },
    "contracts/tornado-core/TornadoTrees.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\n\nimport \"../libs/OwnableMerkleTree.sol\";\nimport \"../interfaces/ITornadoTrees.sol\";\nimport \"../interfaces/IHasher.sol\";\n\ncontract TornadoTrees is ITornadoTrees {\n  OwnableMerkleTree public immutable depositTree;\n  OwnableMerkleTree public immutable withdrawalTree;\n  IHasher public immutable hasher;\n  address public pgRouter;\n\n  event DepositData(address instance, bytes32 indexed hash, uint256 block, uint256 index);\n  event WithdrawalData(address instance, bytes32 indexed hash, uint256 block, uint256 index);\n\n  struct TreeLeaf {\n    address instance;\n    bytes32 hash;\n    uint256 block;\n  }\n\n  modifier onlyPgRouter {\n    require(msg.sender == pgRouter, \"Not authorized\");\n    _;\n  }\n\n  constructor(\n    address _pgRouter,\n    address _hasher2,\n    address _hasher3,\n    uint32 _levels\n  ) {\n    pgRouter = _pgRouter;\n    hasher = IHasher(_hasher3);\n    depositTree = new OwnableMerkleTree(_levels, IHasher(_hasher2));\n    withdrawalTree = new OwnableMerkleTree(_levels, IHasher(_hasher2));\n  }\n\n  function registerDeposit(address _instance, bytes32 _commitment) external override onlyPgRouter {\n    bytes32 leaf = hasher.poseidon([bytes32(bytes20(_instance)), _commitment, bytes32(blockNumber())]);\n    uint32 index = depositTree.insert(leaf);\n    emit DepositData(_instance, _commitment, blockNumber(), uint256(index));\n  }\n\n  function registerWithdrawal(address _instance, bytes32 _nullifier) external override onlyPgRouter {\n    bytes32 leaf = hasher.poseidon([bytes32(bytes20(_instance)), _nullifier, bytes32(blockNumber())]);\n    uint32 index = withdrawalTree.insert(leaf);\n    emit WithdrawalData(_instance, _nullifier, blockNumber(), uint256(index));\n  }\n\n//  function updateRoots(TreeLeaf[] calldata _deposits, TreeLeaf[] calldata _withdrawals) external {\n//    if (_deposits.length > 0) updateDepositTree(_deposits);\n//    if (_withdrawals.length > 0) updateWithdrawalTree(_withdrawals);\n//  }\n//\n//  function updateDepositTree(TreeLeaf[] calldata _deposits) public {\n//    bytes32[] memory leaves = new bytes32[](_deposits.length);\n//    uint256 offset = lastProcessedDepositLeaf;\n//\n//    for (uint256 i = 0; i < _deposits.length; i++) {\n//      TreeLeaf memory deposit = _deposits[i];\n//      bytes32 leafHash = keccak256(abi.encode(deposit.instance, deposit.hash, deposit.block));\n//      require(deposits[offset + i] == leafHash, \"Incorrect deposit\");\n//\n//      leaves[i] = hasher.poseidon([bytes32(uint256(uint160(deposit.instance))), deposit.hash, bytes32(deposit.block)]);\n//      delete deposits[offset + i];\n//\n//      emit DepositData(deposit.instance, deposit.hash, deposit.block, offset + i);\n//    }\n//\n//    lastProcessedDepositLeaf = offset + _deposits.length;\n//    depositTree.bulkInsert(leaves);\n//  }\n//\n//  function updateWithdrawalTree(TreeLeaf[] calldata _withdrawals) public {\n//    bytes32[] memory leaves = new bytes32[](_withdrawals.length);\n//    uint256 offset = lastProcessedWithdrawalLeaf;\n//\n//    for (uint256 i = 0; i < _withdrawals.length; i++) {\n//      TreeLeaf memory withdrawal = _withdrawals[i];\n//      bytes32 leafHash = keccak256(abi.encode(withdrawal.instance, withdrawal.hash, withdrawal.block));\n//      require(withdrawals[offset + i] == leafHash, \"Incorrect withdrawal\");\n//\n//      leaves[i] = hasher.poseidon([bytes32(uint256(uint160(withdrawal.instance))), withdrawal.hash, bytes32(withdrawal.block)]);\n//      delete withdrawals[offset + i];\n//\n//      emit WithdrawalData(withdrawal.instance, withdrawal.hash, withdrawal.block, offset + i);\n//    }\n//\n//    lastProcessedWithdrawalLeaf = offset + _withdrawals.length;\n//    withdrawalTree.bulkInsert(leaves);\n//  }\n\n  function validateRoots(bytes32 _depositRoot, bytes32 _withdrawalRoot) public view {\n    require(depositTree.isKnownRoot(_depositRoot), \"Incorrect deposit tree root\");\n    require(withdrawalTree.isKnownRoot(_withdrawalRoot), \"Incorrect withdrawal tree root\");\n  }\n\n  function depositRoot() external view returns (bytes32) {\n    return depositTree.getLastRoot();\n  }\n\n  function withdrawalRoot() external view returns (bytes32) {\n    return withdrawalTree.getLastRoot();\n  }\n\n  function withdrawalTreeSize() external view returns (uint32) {\n    return withdrawalTree.nextIndex();\n  }\n\n  function depositTreeSize() external view returns (uint32) {\n    return depositTree.nextIndex();\n  }\n\n  function blockNumber() public view virtual returns (uint256) {\n    return block.number;\n  }\n}\n"
    }
  },
  "settings": {
    "optimizer": {
      "enabled": true,
      "runs": 200
    },
    "outputSelection": {
      "*": {
        "*": [
          "abi",
          "evm.bytecode",
          "evm.deployedBytecode",
          "evm.methodIdentifiers",
          "metadata",
          "devdoc",
          "userdoc",
          "storageLayout",
          "evm.gasEstimates"
        ],
        "": [
          "ast"
        ]
      }
    },
    "metadata": {
      "useLiteralContent": true
    }
  }
}